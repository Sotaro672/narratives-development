# backend\deploy-backend.ps1
param(
  # Example explicit image: asia-northeast1-docker.pkg.dev/<PROJECT>/<REPO>/<SERVICE>:<TAG>
  [string]$Image,

  # Region / Cloud Run service name
  [string]$Region      = "asia-northeast1",
  [string]$ServiceName = "narratives-backend",

  # Artifact Registry repository name (Docker)
  [string]$RepoName    = "narratives-backend",

  # If -Image is auto-generated and Podman is available, use local podman build/push.
  # If Podman is unavailable, fallback to Cloud Build automatically.
  [bool]$PreferPodmanWhenAvailable = $true
)

$ErrorActionPreference = "Stop"

function Write-Step($msg) { Write-Host "== $msg ==" -ForegroundColor Cyan }
function Write-Ok($msg)   { Write-Host "OK: $msg" -ForegroundColor Green }
function Write-Warn($msg) { Write-Host "!! $msg ==" -ForegroundColor Yellow }

function Normalize-EnvValue([string]$v) {
  if ($null -eq $v) { return "" }
  $s = $v.Trim()
  # strip surrounding quotes
  if (($s.StartsWith('"') -and $s.EndsWith('"')) -or ($s.StartsWith("'") -and $s.EndsWith("'"))) {
    $s = $s.Substring(1, $s.Length - 2)
  }
  return $s
}

function Read-EnvFile([string]$path) {
  $map = @{}
  foreach ($line in Get-Content $path) {
    $trim = $line.Trim()
    if (-not $trim) { continue }            # empty
    if ($trim.StartsWith("#")) { continue } # comment

    $idx = $trim.IndexOf("=")
    if ($idx -lt 1) { continue }

    $key   = $trim.Substring(0, $idx).Trim()
    $value = $trim.Substring($idx + 1)

    $map[$key] = (Normalize-EnvValue $value)
  }
  return $map
}

# ------------------------------------------------------------
# 0) gcloud のプロジェクト確認
# ------------------------------------------------------------
Write-Step "Starting deploy-backend.ps1"

# gcloud の対話・更新チェック・ページャを抑止（無音停止/入力待ちを減らす）
$env:CLOUDSDK_CORE_DISABLE_PROMPTS = "1"
$env:CLOUDSDK_COMPONENT_MANAGER_DISABLE_UPDATE_CHECK = "1"

# gcloud.cmd をフルパスで固定（gcloud.ps1 を踏まない）
$GCLOUD = (Get-Command gcloud.cmd -ErrorAction Stop).Source
Write-Step "Using gcloud.cmd: $GCLOUD"

# pager を無効化（環境によってはページャ待ちが発生するため）
# 失敗しても継続
try { & $GCLOUD config set core/pager "" | Out-Null } catch { }

# ProjectId 取得（stderr を捨てない。止まるなら理由が出る）
Write-Step "Resolving GCP project id (gcloud config get-value project)"
$ProjectId = (& $GCLOUD config get-value project --verbosity=debug).Trim()
if (-not $ProjectId) {
  throw "gcloud config project is not set. Example: gcloud config set project <YOUR_PROJECT_ID>"
}
Write-Step "Using project: $ProjectId"

# Cloud Run service account
$RunServiceAccount = "narratives-backend-sa@$ProjectId.iam.gserviceaccount.com"

# スクリプト / ソースディレクトリ
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$SourceDir = $ScriptDir

# ------------------------------------------------------------
# 1) Go build チェック
# ------------------------------------------------------------
$MainGo = Join-Path $SourceDir "cmd\api\main.go"
if (-not (Test-Path $MainGo)) {
  throw "Go main file not found: $MainGo"
}

Write-Step "go build check (cmd/api)"
Push-Location $SourceDir
try {
  go version | Out-Null
  go build ./cmd/api
} finally {
  Pop-Location
}
Write-Ok "go build succeeded"

# ------------------------------------------------------------
# 2) Artifact Registry リポジトリ確認
# ------------------------------------------------------------
Write-Step "Ensuring Artifact Registry repository: ${RepoName}"
$repoExists = $true
try {
  & $GCLOUD artifacts repositories describe $RepoName --location=$Region --project=$ProjectId | Out-Null
} catch {
  $repoExists = $false
}

if (-not $repoExists) {
  Write-Warn "Repository '${RepoName}' not found. Creating it..."
  & $GCLOUD artifacts repositories create $RepoName `
    --repository-format=docker `
    --location=$Region `
    --description="Backend images for ${ServiceName}" `
    --project=$ProjectId | Out-Null
  Write-Ok "Repository created: ${RepoName}"
} else {
  Write-Ok "Repository exists: ${RepoName}"
}

# ------------------------------------------------------------
# 3) イメージ名決定
# ------------------------------------------------------------
$AutoGenerated = $false
if ([string]::IsNullOrWhiteSpace($Image)) {
  $RegistryHost = "${Region}-docker.pkg.dev"
  $Tag = Get-Date -Format "yyyyMMdd-HHmmss"
  $Image = "${RegistryHost}/${ProjectId}/${RepoName}/${ServiceName}:${Tag}"
  $AutoGenerated = $true
  Write-Step "No image specified. Generated image: $Image"
} else {
  Write-Step "Using specified image: $Image"
}

# ------------------------------------------------------------
# 4) ビルド & push (Podman 優先)
# ------------------------------------------------------------
function Try-StartPodmanMachine {
  try {
    # Windows の Podman Desktop/WSL2 で machine が止まっているケース対策（best-effort）
    podman machine start | Out-Null
  } catch {
    # ignore
  }
}

function Test-PodmanAvailable {
  try {
    podman info | Out-Null
    return $true
  } catch {
    Try-StartPodmanMachine
    try {
      podman info | Out-Null
      return $true
    } catch {
      return $false
    }
  }
}

function Configure-ArtifactRegistryAuthForPodman([string]$RegistryHost) {
  # Podman 用に Artifact Registry へログインする（Docker Desktop 前提の設定に依存しない）
  # username: oauth2accesstoken / password: gcloud access token
  Write-Step "Logging in to Artifact Registry (Podman): ${RegistryHost}"
  $token = (& $GCLOUD auth print-access-token --project $ProjectId).Trim()
  if (-not $token) {
    throw "Failed to obtain access token. Run: gcloud auth login  (and/or) gcloud auth application-default login"
  }

  # --password-stdin を使う（履歴に残りにくい）
  $token | podman login $RegistryHost --username "oauth2accesstoken" --password-stdin | Out-Null
  if ($LASTEXITCODE -ne 0) { throw "podman login failed with exit code $LASTEXITCODE" }

  Write-Ok "Podman registry login succeeded"
}

if ($AutoGenerated) {
  $PodmanAvailable = $false
  if ($PreferPodmanWhenAvailable) {
    $PodmanAvailable = Test-PodmanAvailable
  }

  if ($PodmanAvailable) {
    Write-Step "Podman detected. Using local podman build & push"

    $RegistryHost = "${Region}-docker.pkg.dev"
    Configure-ArtifactRegistryAuthForPodman $RegistryHost

    Push-Location $SourceDir
    try {
      podman build -t "$Image" .
      if ($LASTEXITCODE -ne 0) { throw "podman build failed with exit code $LASTEXITCODE" }

      podman push "$Image"
      if ($LASTEXITCODE -ne 0) { throw "podman push failed with exit code $LASTEXITCODE" }
    } finally {
      Pop-Location
    }
    Write-Ok "Image build & push completed (Podman)"
  } else {
    Write-Step "Podman not available. Using Cloud Build"
    & $GCLOUD builds submit --tag "$Image" --project "$ProjectId"
    if ($LASTEXITCODE -ne 0) {
      throw "Cloud Build failed. exit code: $LASTEXITCODE"
    }
    Write-Ok "Image build & push completed (Cloud Build)"
  }
} else {
  Write-Warn "Auto-image disabled (explicit -Image). Skipping build/push."
}

# ------------------------------------------------------------
# 5) Cloud Run に渡す環境変数を組み立てる
#    - backend/.env から「バックエンド用キーだけ」拾う
#    - TOKEN_ICON_* / TOKEN_CONTENTS_BUCKET / LIST_BUCKET / AVATAR_ICON_* を追加
#    - 注意: ここは --update-env-vars を使い、既存 env を不用意に消さない
# ------------------------------------------------------------
Write-Step "Collecting env vars for Cloud Run"

# Cloud Run に渡したいキー（あなたの .env 内容に合わせて）
$AllowedKeys = @(
  # Project / Firestore
  "GCP_PROJECT_ID",
  "FIREBASE_PROJECT_ID",
  "FIRESTORE_PROJECT_ID",

  # SendGrid
  "SENDGRID_API_KEY",
  "SENDGRID_FROM",
  "CONSOLE_BASE_URL",

  # Solana
  "SOLANA_RPC_URL",
  "SOLANA_MINT_KEY_SECRET",

  # Arweave / Irys
  "ARWEAVE_BASE_URL",

  # GCS buckets
  "TOKEN_ICON_BUCKET",
  "TOKEN_CONTENTS_BUCKET",

  # ✅ NEW: List images bucket
  "LIST_BUCKET",

  # ✅ NEW: Avatar icon bucket (Signed URL)
  "AVATAR_ICON_BUCKET",

  # Signed URL signer email
  "TOKEN_ICON_SIGNER_EMAIL",
  "GCS_SIGNER_EMAIL",

  # ✅ NEW: Avatar icon signer email
  "AVATAR_ICON_SIGNER_EMAIL",

  # ✅ NEW: checkout self-callback base URL
  "SELF_BASE_URL"
)

# まず必ずセットするもの（GOOGLE_CLOUD_PROJECT はランタイムで参照しがち）
$envMap = @{}
$envMap["GOOGLE_CLOUD_PROJECT"] = $ProjectId

# backend/.env を読む想定
$EnvFile = Join-Path $SourceDir ".env"
if (Test-Path $EnvFile) {
  Write-Ok "Found .env: $EnvFile"
  $fileMap = Read-EnvFile $EnvFile

  foreach ($k in $AllowedKeys) {
    if ($fileMap.ContainsKey($k)) {
      $envMap[$k] = $fileMap[$k]
    }
  }
} else {
  Write-Warn ".env file not found at $EnvFile. Will only set GOOGLE_CLOUD_PROJECT and project-id defaults."
}

# .env に無い場合でも、最低限プロジェクトID系は揃える（container.go が参照する想定の保険）
if (-not $envMap.ContainsKey("GCP_PROJECT_ID"))       { $envMap["GCP_PROJECT_ID"] = $ProjectId }
if (-not $envMap.ContainsKey("FIREBASE_PROJECT_ID"))  { $envMap["FIREBASE_PROJECT_ID"] = $ProjectId }
if (-not $envMap.ContainsKey("FIRESTORE_PROJECT_ID")) { $envMap["FIRESTORE_PROJECT_ID"] = $ProjectId }

# ✅ NEW: Avatar icon bucket defaults（.env が無くても動く保険）
if (-not $envMap.ContainsKey("AVATAR_ICON_BUCKET")) {
  $envMap["AVATAR_ICON_BUCKET"] = "narratives-development_avatar_icon"
}

# ✅ NEW: Avatar icon signer email defaults
# - まず .env の AVATAR_ICON_SIGNER_EMAIL を優先
# - 無ければ GCS_SIGNER_EMAIL / TOKEN_ICON_SIGNER_EMAIL を流用
# - 最後に Cloud Run runtime SA を保険として入れる
if (-not $envMap.ContainsKey("AVATAR_ICON_SIGNER_EMAIL")) {
  if ($envMap.ContainsKey("GCS_SIGNER_EMAIL") -and $envMap["GCS_SIGNER_EMAIL"].Trim()) {
    $envMap["AVATAR_ICON_SIGNER_EMAIL"] = $envMap["GCS_SIGNER_EMAIL"]
  } elseif ($envMap.ContainsKey("TOKEN_ICON_SIGNER_EMAIL") -and $envMap["TOKEN_ICON_SIGNER_EMAIL"].Trim()) {
    $envMap["AVATAR_ICON_SIGNER_EMAIL"] = $envMap["TOKEN_ICON_SIGNER_EMAIL"]
  } else {
    $envMap["AVATAR_ICON_SIGNER_EMAIL"] = $RunServiceAccount
  }
}

# ✅ NEW: SELF_BASE_URL（/mall/me/invoices の checkout に必須）
# - .env に無ければ Cloud Run の service URL から自動解決（既に service が存在する前提）
if (-not $envMap.ContainsKey("SELF_BASE_URL") -or [string]::IsNullOrWhiteSpace($envMap["SELF_BASE_URL"])) {
  try {
    $selfUrl = (& $GCLOUD run services describe $ServiceName `
      --region $Region `
      --project $ProjectId `
      --format "value(status.url)").Trim()

    if ($selfUrl) {
      $envMap["SELF_BASE_URL"] = $selfUrl.TrimEnd("/")
      Write-Ok "SELF_BASE_URL resolved from Cloud Run: $($envMap["SELF_BASE_URL"])"
    } else {
      Write-Warn "SELF_BASE_URL could not be resolved (service url empty). Please set it in .env."
    }
  } catch {
    Write-Warn "Failed to resolve SELF_BASE_URL from Cloud Run. Please set it in .env."
  }
}

# Cloud Run 用 "k=v,k=v" にする（値にカンマが入るケースは想定外）
$envPairs = @()
foreach ($k in $envMap.Keys) {
  $v = $envMap[$k]
  if ($null -eq $v) { $v = "" }
  $envPairs += "$k=$v"
}
$envArg = [string]::Join(",", $envPairs)

Write-Step "Env vars to update: $envArg"

# ------------------------------------------------------------
# 6) Cloud Run へデプロイ
# ------------------------------------------------------------
Write-Step "Deploying to Cloud Run"

$deployArgs = @(
  "run","deploy", $ServiceName,
  "--image",           $Image,
  "--region",          $Region,
  "--platform",        "managed",
  "--allow-unauthenticated",
  "--service-account", $RunServiceAccount,

  # ★重要: 既存 env を消さずに「追加/更新」する
  "--update-env-vars", $envArg,

  "--min-instances",   "0",
  "--max-instances",   "5",
  "--memory",          "512Mi",
  "--cpu",             "1",
  "--concurrency",     "80",
  "--timeout",         "60s",
  "--project",         $ProjectId
)

& $GCLOUD @deployArgs
if ($LASTEXITCODE -ne 0) {
  throw "gcloud run deploy failed. exit code: $LASTEXITCODE"
}

Write-Ok "Cloud Run deployment finished: service '${ServiceName}'"
if ($AutoGenerated) {
  Write-Ok "Deployed with image: ${Image}"
}
