// backend/internal/adapters/out/firestore/production_repository_pg.go
package firestore

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	dbcommon "narratives/internal/adapters/out/db/common"
	proddom "narratives/internal/domain/production"
)

type ProductionRepositoryPG struct {
	DB *sql.DB
}

func NewProductionRepositoryPG(db *sql.DB) *ProductionRepositoryPG {
	return &ProductionRepositoryPG{DB: db}
}

// ======================================================================
// ProductionRepo facade for usecase.ProductionRepo
// (This makes ProductionRepositoryPG satisfy usecase.ProductionRepo.)
// ======================================================================

// GetByID(ctx,id) (Production, error)  ← usecase側が期待する形（値返し）
func (r *ProductionRepositoryPG) GetByID(ctx context.Context, id string) (proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)
	const q = `
SELECT
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
FROM productions
WHERE id = $1`
	row := run.QueryRowContext(ctx, q, strings.TrimSpace(id))
	p, err := scanProduction(row)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return proddom.Production{}, proddom.ErrNotFound
		}
		return proddom.Production{}, err
	}
	return p, nil
}

// Exists returns true if a row with that ID exists.
func (r *ProductionRepositoryPG) Exists(ctx context.Context, id string) (bool, error) {
	run := dbcommon.GetRunner(ctx, r.DB)
	const q = `SELECT 1 FROM productions WHERE id = $1`
	var dummy int
	err := run.QueryRowContext(ctx, q, strings.TrimSpace(id)).Scan(&dummy)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

// Create(ctx,p Production) (Production, error)
// This wraps the lower-level CreateProductionInput API.
func (r *ProductionRepositoryPG) Create(ctx context.Context, p proddom.Production) (proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	// map Production -> CreateProductionInput
	// ID is generated by DB, so we don't pass p.ID.
	// CreatedAt in CreateProductionInput is *time.Time (optional)
	var createdAtPtr *time.Time
	if !p.CreatedAt.IsZero() {
		t := p.CreatedAt.UTC()
		createdAtPtr = &t
	}

	in := proddom.CreateProductionInput{
		ProductBlueprintID: strings.TrimSpace(p.ProductBlueprintID),
		AssigneeID:         strings.TrimSpace(p.AssigneeID),
		Models:             p.Models,
		Status: func(s proddom.ProductionStatus) *proddom.ProductionStatus {
			// if empty string, treat as nil so DB default 'manufacturing' can apply
			st := proddom.ProductionStatus(strings.TrimSpace(string(s)))
			if st == "" {
				return nil
			}
			return &st
		}(p.Status),
		PrintedAt:   p.PrintedAt,
		InspectedAt: p.InspectedAt,
		CreatedBy:   p.CreatedBy,
		CreatedAt:   createdAtPtr,
	}

	modelsJSON, err := json.Marshal(in.Models)
	if err != nil {
		return proddom.Production{}, err
	}

	const q = `
INSERT INTO productions (
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
) VALUES (
  gen_random_uuid()::text, $1, $2, $3::jsonb, COALESCE($4, 'manufacturing'),
  $5, $6,
  $7, COALESCE($8, NOW()),
  NULL, NULL,
  NULL, NULL
)
RETURNING
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
`
	row := run.QueryRowContext(ctx, q,
		strings.TrimSpace(in.ProductBlueprintID),
		strings.TrimSpace(in.AssigneeID),
		string(modelsJSON),
		statusOrNil(in.Status),
		dbcommon.ToDBTime(in.PrintedAt),
		dbcommon.ToDBTime(in.InspectedAt),
		dbcommon.ToDBText(in.CreatedBy),
		dbcommon.ToDBTime(in.CreatedAt),
	)

	createdProd, err := scanProduction(row)
	if err != nil {
		if dbcommon.IsUniqueViolation(err) {
			return proddom.Production{}, proddom.ErrConflict
		}
		return proddom.Production{}, err
	}
	return createdProd, nil
}

// Save(ctx,p Production) (Production, error)
// "Upsert-ish": if p.ID is empty or not found -> Create(); else -> Update().
func (r *ProductionRepositoryPG) Save(ctx context.Context, p proddom.Production) (proddom.Production, error) {
	id := strings.TrimSpace(p.ID)
	if id == "" {
		// No ID given, just Create
		return r.Create(ctx, p)
	}

	exists, err := r.Exists(ctx, id)
	if err != nil {
		return proddom.Production{}, err
	}
	if !exists {
		// Treat as create (ignore caller-provided ID; DB will generate)
		return r.Create(ctx, p)
	}

	// map Production -> UpdateProductionInput for Update()
	patch := proddom.UpdateProductionInput{
		ProductBlueprintID: strPtrIfNonEmpty(p.ProductBlueprintID),
		AssigneeID:         strPtrIfNonEmpty(p.AssigneeID),
		Models: func(ms []proddom.ModelQuantity) *[]proddom.ModelQuantity {
			if len(ms) == 0 {
				// returning empty slice as empty slice is still intentional
				empty := make([]proddom.ModelQuantity, 0)
				return &empty
			}
			cp := make([]proddom.ModelQuantity, len(ms))
			copy(cp, ms)
			return &cp
		}(p.Models),
		Status: func(s proddom.ProductionStatus) *proddom.ProductionStatus {
			st := proddom.ProductionStatus(strings.TrimSpace(string(s)))
			if st == "" {
				return nil
			}
			return &st
		}(p.Status),
		PrintedAt:   p.PrintedAt,
		InspectedAt: p.InspectedAt,
		UpdatedBy:   p.UpdatedBy,
		DeletedBy:   p.DeletedBy,
		DeletedAt:   p.DeletedAt,
	}

	updatedPtr, err := r.Update(ctx, id, patch)
	if err != nil {
		return proddom.Production{}, err
	}
	if updatedPtr == nil {
		// should not really happen, but keep defensive fallback
		return proddom.Production{}, proddom.ErrNotFound
	}
	return *updatedPtr, nil
}

// helper used in Save(): turn "" into nil
func strPtrIfNonEmpty(s string) *string {
	s2 := strings.TrimSpace(s)
	if s2 == "" {
		return nil
	}
	return &s2
}

// ======================================================================
// Lower-level repository methods (richer PG-facing API)
// ======================================================================

func (r *ProductionRepositoryPG) GetByModelID(ctx context.Context, modelID string) ([]proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)
	const q = `
SELECT
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
FROM productions
WHERE EXISTS (
  SELECT 1
  FROM jsonb_array_elements(models) AS v(elem)
  WHERE v.elem->>'modelId' = $1
)
ORDER BY created_at DESC, id DESC`
	rows, err := run.QueryContext(ctx, q, strings.TrimSpace(modelID))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []proddom.Production
	for rows.Next() {
		p, err := scanProduction(rows)
		if err != nil {
			return nil, err
		}
		out = append(out, p)
	}
	return out, rows.Err()
}

func (r *ProductionRepositoryPG) List(ctx context.Context, filter proddom.Filter, sort proddom.Sort, page proddom.Page) (proddom.PageResult, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	where, args := buildProductionWhere(filter)
	whereSQL := ""
	if len(where) > 0 {
		whereSQL = "WHERE " + strings.Join(where, " AND ")
	}

	orderBy := buildProductionOrderBy(sort)
	if orderBy == "" {
		orderBy = "ORDER BY created_at DESC, id DESC"
	}

	pageNum, perPage, offset := dbcommon.NormalizePage(page.Number, page.PerPage, 50, 200)

	var total int
	if err := run.QueryRowContext(ctx, "SELECT COUNT(*) FROM productions "+whereSQL, args...).Scan(&total); err != nil {
		return proddom.PageResult{}, err
	}

	q := fmt.Sprintf(`
SELECT
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
FROM productions
%s
%s
LIMIT $%d OFFSET $%d
`, whereSQL, orderBy, len(args)+1, len(args)+2)

	args = append(args, perPage, offset)
	rows, err := run.QueryContext(ctx, q, args...)
	if err != nil {
		return proddom.PageResult{}, err
	}
	defer rows.Close()

	items := make([]proddom.Production, 0, perPage)
	for rows.Next() {
		p, err := scanProduction(rows)
		if err != nil {
			return proddom.PageResult{}, err
		}
		items = append(items, p)
	}
	if err := rows.Err(); err != nil {
		return proddom.PageResult{}, err
	}

	return proddom.PageResult{
		Items:      items,
		TotalCount: total,
		TotalPages: dbcommon.ComputeTotalPages(total, perPage),
		Page:       pageNum,
		PerPage:    perPage,
	}, nil
}

func (r *ProductionRepositoryPG) Count(ctx context.Context, filter proddom.Filter) (int, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	where, args := buildProductionWhere(filter)
	whereSQL := ""
	if len(where) > 0 {
		whereSQL = "WHERE " + strings.Join(where, " AND ")
	}

	var total int
	if err := run.QueryRowContext(ctx, "SELECT COUNT(*) FROM productions "+whereSQL, args...).Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

// NOTE: the lower-level Create() has been inlined into the facade Create() above,
// because the facade needed to adapt types. We keep a separate Update().

func (r *ProductionRepositoryPG) Update(ctx context.Context, id string, patch proddom.UpdateProductionInput) (*proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	sets := []string{}
	args := []any{}
	i := 1

	setText := func(col string, p *string) {
		if p != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", col, i))
			args = append(args, strings.TrimSpace(*p))
			i++
		}
	}
	setTime := func(col string, t *time.Time) {
		if t != nil {
			sets = append(sets, fmt.Sprintf("%s = $%d", col, i))
			args = append(args, t.UTC())
			i++
		}
	}

	setText("product_blueprint_id", patch.ProductBlueprintID)
	setText("assignee_id", patch.AssigneeID)

	if patch.Models != nil {
		jb, err := json.Marshal(*patch.Models)
		if err != nil {
			return nil, err
		}
		sets = append(sets, fmt.Sprintf("models = $%d::jsonb", i))
		args = append(args, string(jb))
		i++
	}

	if patch.Status != nil {
		sets = append(sets, fmt.Sprintf("status = $%d", i))
		args = append(args, strings.TrimSpace(string(*patch.Status)))
		i++
	}

	setTime("printed_at", patch.PrintedAt)
	setTime("inspected_at", patch.InspectedAt)

	// soft delete fields
	if patch.DeletedAt != nil {
		setTime("deleted_at", patch.DeletedAt)
	}
	if patch.DeletedBy != nil {
		sets = append(sets, fmt.Sprintf("deleted_by = $%d", i))
		args = append(args, strings.TrimSpace(*patch.DeletedBy))
		i++
	}

	// updated_by if provided
	if patch.UpdatedBy != nil {
		sets = append(sets, fmt.Sprintf("updated_by = $%d", i))
		args = append(args, strings.TrimSpace(*patch.UpdatedBy))
		i++
	}
	// always bump updated_at
	sets = append(sets, fmt.Sprintf("updated_at = $%d", i))
	args = append(args, time.Now().UTC())
	i++

	if len(sets) == 0 {
		// nothing changed => just reload current record
		prod, err := r.GetByID(ctx, id)
		if err != nil {
			return nil, err
		}
		return &prod, nil
	}

	args = append(args, strings.TrimSpace(id))
	q := fmt.Sprintf(`
UPDATE productions
SET %s
WHERE id = $%d
RETURNING
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
`, strings.Join(sets, ", "), i)

	row := run.QueryRowContext(ctx, q, args...)
	p, err := scanProduction(row)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, proddom.ErrNotFound
		}
		if dbcommon.IsUniqueViolation(err) {
			return nil, proddom.ErrConflict
		}
		return nil, err
	}
	return &p, nil
}

func (r *ProductionRepositoryPG) Delete(ctx context.Context, id string) error {
	run := dbcommon.GetRunner(ctx, r.DB)
	res, err := run.ExecContext(ctx, `DELETE FROM productions WHERE id = $1`, strings.TrimSpace(id))
	if err != nil {
		return err
	}
	aff, _ := res.RowsAffected()
	if aff == 0 {
		return proddom.ErrNotFound
	}
	return nil
}

func (r *ProductionRepositoryPG) MarkPrinted(ctx context.Context, id string, in proddom.MarkPrintedInput) (*proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	at := in.At.UTC()
	q := `
UPDATE productions
SET status = 'printed',
    printed_at = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
`
	row := run.QueryRowContext(ctx, q, at, strings.TrimSpace(id))
	p, err := scanProduction(row)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, proddom.ErrNotFound
		}
		return nil, err
	}
	return &p, nil
}

func (r *ProductionRepositoryPG) MarkInspected(ctx context.Context, id string, in proddom.MarkInspectedInput) (*proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	at := in.At.UTC()
	q := `
UPDATE productions
SET status = 'inspected',
    inspected_at = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
`
	row := run.QueryRowContext(ctx, q, at, strings.TrimSpace(id))
	p, err := scanProduction(row)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, proddom.ErrNotFound
		}
		return nil, err
	}
	return &p, nil
}

func (r *ProductionRepositoryPG) ResetToManufacturing(ctx context.Context, id string) (*proddom.Production, error) {
	run := dbcommon.GetRunner(ctx, r.DB)

	q := `
UPDATE productions
SET status = 'manufacturing',
    printed_at = NULL,
    inspected_at = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING
  id, product_blueprint_id, assignee_id, models, status,
  printed_at, inspected_at,
  created_by, created_at,
  updated_by, updated_at,
  deleted_by, deleted_at
`
	row := run.QueryRowContext(ctx, q, strings.TrimSpace(id))
	p, err := scanProduction(row)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, proddom.ErrNotFound
		}
		return nil, err
	}
	return &p, nil
}

// WithTx starts a transaction, injects it into ctx, and commits/rolls back.
func (r *ProductionRepositoryPG) WithTx(ctx context.Context, fn func(ctx context.Context) error) error {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txCtx := dbcommon.CtxWithTx(ctx, tx)

	defer func() {
		if p := recover(); p != nil {
			_ = tx.Rollback()
			panic(p)
		}
	}()

	if err := fn(txCtx); err != nil {
		_ = tx.Rollback()
		return err
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// ========================
// Helpers
// ========================

func scanProduction(s dbcommon.RowScanner) (proddom.Production, error) {
	var (
		id, blueprintID, assigneeID string
		modelsRaw                   []byte
		statusStr                   string
		printedAtNS                 sql.NullTime
		inspectedAtNS               sql.NullTime
		createdByNS                 sql.NullString
		createdAt                   sql.NullTime
		updatedByNS                 sql.NullString
		updatedAtNS                 sql.NullTime
		deletedByNS                 sql.NullString
		deletedAtNS                 sql.NullTime
	)
	if err := s.Scan(
		&id, &blueprintID, &assigneeID, &modelsRaw, &statusStr,
		&printedAtNS, &inspectedAtNS,
		&createdByNS, &createdAt,
		&updatedByNS, &updatedAtNS,
		&deletedByNS, &deletedAtNS,
	); err != nil {
		return proddom.Production{}, err
	}

	var models []proddom.ModelQuantity
	if len(modelsRaw) > 0 {
		_ = json.Unmarshal(modelsRaw, &models) // tolerate malformed
	}

	toStrPtr := func(ns sql.NullString) *string {
		if ns.Valid {
			v := strings.TrimSpace(ns.String)
			if v != "" {
				return &v
			}
		}
		return nil
	}
	toTimePtr := func(nt sql.NullTime) *time.Time {
		if nt.Valid {
			t := nt.Time.UTC()
			return &t
		}
		return nil
	}

	var created time.Time
	if createdAt.Valid {
		created = createdAt.Time.UTC()
	}

	return proddom.Production{
		ID:                 strings.TrimSpace(id),
		ProductBlueprintID: strings.TrimSpace(blueprintID),
		AssigneeID:         strings.TrimSpace(assigneeID),
		Models:             models,
		Status:             proddom.ProductionStatus(strings.TrimSpace(statusStr)),
		PrintedAt:          toTimePtr(printedAtNS),
		InspectedAt:        toTimePtr(inspectedAtNS),
		CreatedBy:          toStrPtr(createdByNS),
		CreatedAt:          created,
		UpdatedBy:          toStrPtr(updatedByNS),
		UpdatedAt: func(nt sql.NullTime) time.Time {
			if nt.Valid {
				return nt.Time.UTC()
			}
			return time.Time{}
		}(updatedAtNS),
		DeletedBy: toStrPtr(deletedByNS),
		DeletedAt: toTimePtr(deletedAtNS),
	}, nil
}

func buildProductionWhere(f proddom.Filter) ([]string, []any) {
	where := []string{}
	args := []any{}

	addEq := func(col, v string) {
		v = strings.TrimSpace(v)
		if v != "" {
			where = append(where, fmt.Sprintf("%s = $%d", col, len(args)+1))
			args = append(args, v)
		}
	}

	addEq("id", f.ID)
	addEq("product_blueprint_id", f.ProductBlueprintID)
	addEq("assignee_id", f.AssigneeID)

	// ModelID containment in JSONB array
	if v := strings.TrimSpace(f.ModelID); v != "" {
		where = append(where, fmt.Sprintf(`
EXISTS (
  SELECT 1
  FROM jsonb_array_elements(models) AS v(elem)
  WHERE v.elem->>'modelId' = $%d
)`, len(args)+1))
		args = append(args, v)
	}

	// Status IN (...)
	if len(f.Statuses) > 0 {
		base := len(args)
		ph := make([]string, len(f.Statuses))
		for i, s := range f.Statuses {
			args = append(args, strings.TrimSpace(string(s)))
			ph[i] = fmt.Sprintf("$%d", base+i+1)
		}
		where = append(where, fmt.Sprintf("status IN (%s)", strings.Join(ph, ",")))
	}

	// Time ranges
	if f.PrintedFrom != nil {
		where = append(where, fmt.Sprintf("(printed_at IS NOT NULL AND printed_at >= $%d)", len(args)+1))
		args = append(args, f.PrintedFrom.UTC())
	}
	if f.PrintedTo != nil {
		where = append(where, fmt.Sprintf("(printed_at IS NOT NULL AND printed_at < $%d)", len(args)+1))
		args = append(args, f.PrintedTo.UTC())
	}
	if f.InspectedFrom != nil {
		where = append(where, fmt.Sprintf("(inspected_at IS NOT NULL AND inspected_at >= $%d)", len(args)+1))
		args = append(args, f.InspectedFrom.UTC())
	}
	if f.InspectedTo != nil {
		where = append(where, fmt.Sprintf("(inspected_at IS NOT NULL AND inspected_at < $%d)", len(args)+1))
		args = append(args, f.InspectedTo.UTC())
	}
	if f.CreatedFrom != nil {
		where = append(where, fmt.Sprintf("created_at >= $%d", len(args)+1))
		args = append(args, f.CreatedFrom.UTC())
	}
	if f.CreatedTo != nil {
		where = append(where, fmt.Sprintf("created_at < $%d", len(args)+1))
		args = append(args, f.CreatedTo.UTC())
	}
	if f.UpdatedFrom != nil {
		where = append(where, fmt.Sprintf("(updated_at IS NOT NULL AND updated_at >= $%d)", len(args)+1))
		args = append(args, f.UpdatedFrom.UTC())
	}
	if f.UpdatedTo != nil {
		where = append(where, fmt.Sprintf("(updated_at IS NOT NULL AND updated_at < $%d)", len(args)+1))
		args = append(args, f.UpdatedTo.UTC())
	}
	if f.DeletedFrom != nil {
		where = append(where, fmt.Sprintf("(deleted_at IS NOT NULL AND deleted_at >= $%d)", len(args)+1))
		args = append(args, f.DeletedFrom.UTC())
	}
	if f.DeletedTo != nil {
		where = append(where, fmt.Sprintf("(deleted_at IS NOT NULL AND deleted_at < $%d)", len(args)+1))
		args = append(args, f.DeletedTo.UTC())
	}

	// Deleted tri-state
	if f.Deleted != nil {
		if *f.Deleted {
			where = append(where, "deleted_at IS NOT NULL")
		} else {
			where = append(where, "deleted_at IS NULL")
		}
	}

	return where, args
}

func buildProductionOrderBy(s proddom.Sort) string {
	col := strings.ToLower(strings.TrimSpace(string(s.Column)))
	switch col {
	case "id":
		col = "id"
	case "createdat", "created_at":
		col = "created_at"
	case "updatedat", "updated_at":
		col = "updated_at"
	case "printedat", "printed_at":
		col = "printed_at"
	case "inspectedat", "inspected_at":
		col = "inspected_at"
	case "status":
		col = "status"
	default:
		return ""
	}
	dir := strings.ToUpper(strings.TrimSpace(string(s.Order)))
	if dir != "ASC" && dir != "DESC" {
		dir = "DESC"
	}
	return fmt.Sprintf("ORDER BY %s %s, id %s", col, dir, dir)
}

func statusOrNil(s *proddom.ProductionStatus) any {
	if s == nil {
		return nil
	}
	v := strings.TrimSpace(string(*s))
	if v == "" {
		return nil
	}
	return v
}
