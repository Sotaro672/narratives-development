// backend\internal\domain\tokenOperation\entity.go
package tokenOperation

import (
	"errors"
	"strings"
)

// ===============================
// Types (mirror TS)
// ===============================

// TokenOperation mirrors web-app/src/shared/types/tokenOperation.ts
type TokenOperation struct {
	ID               string
	TokenBlueprintID string
	AssigneeID       string
}

// TokenOperationExtended mirrors TokenOperationExtended (server-side join result)
type TokenOperationExtended struct {
	TokenOperation
	TokenName    string
	Symbol       string
	BrandID      string
	AssigneeName string
	BrandName    string
}

// ===============================
// Errors
// ===============================

var (
	ErrInvalidID               = errors.New("tokenOperation: invalid id")
	ErrInvalidTokenBlueprintID = errors.New("tokenOperation: invalid tokenBlueprintId")
	ErrInvalidAssigneeID       = errors.New("tokenOperation: invalid assigneeId")

	// Extended-only fields
	ErrInvalidTokenName    = errors.New("tokenOperation: invalid tokenName")
	ErrInvalidSymbol       = errors.New("tokenOperation: invalid symbol")
	ErrInvalidBrandID      = errors.New("tokenOperation: invalid brandId")
	ErrInvalidAssigneeName = errors.New("tokenOperation: invalid assigneeName")
	ErrInvalidBrandName    = errors.New("tokenOperation: invalid brandName")
)

// ===============================
// Policy (align with tokenOperationConstants.ts)
// Set limits to 0 to disable those checks.
// ===============================

var (
	EnforceIDPrefix        = false
	TokenOperationIDPrefix = ""
	MaxIDLength            = 128

	MaxNameLength   = 200
	MaxSymbolLength = 32
)

// ===============================
// Constructors
// ===============================

func New(id, tokenBlueprintID, assigneeID string) (TokenOperation, error) {
	op := TokenOperation{
		ID:               strings.TrimSpace(id),
		TokenBlueprintID: strings.TrimSpace(tokenBlueprintID),
		AssigneeID:       strings.TrimSpace(assigneeID),
	}
	if err := op.validate(); err != nil {
		return TokenOperation{}, err
	}
	return op, nil
}

// Helper for create-usecase where ID is generated by server.
func NewWithGeneratedID(id string, tokenBlueprintID, assigneeID string) (TokenOperation, error) {
	return New(id, tokenBlueprintID, assigneeID)
}

// Build extended model (all extra fields are required here)
func NewExtended(
	base TokenOperation,
	tokenName, symbol, brandID, assigneeName, brandName string,
) (TokenOperationExtended, error) {
	e := TokenOperationExtended{
		TokenOperation: base,
		TokenName:      strings.TrimSpace(tokenName),
		Symbol:         strings.TrimSpace(symbol),
		BrandID:        strings.TrimSpace(brandID),
		AssigneeName:   strings.TrimSpace(assigneeName),
		BrandName:      strings.TrimSpace(brandName),
	}
	if err := e.validateExtended(); err != nil {
		return TokenOperationExtended{}, err
	}
	return e, nil
}

// ===============================
// Behavior
// ===============================

func (t *TokenOperation) ReassignAssignee(assigneeID string) error {
	assigneeID = strings.TrimSpace(assigneeID)
	if assigneeID == "" {
		return ErrInvalidAssigneeID
	}
	t.AssigneeID = assigneeID
	return nil
}

func (t *TokenOperation) ReassignBlueprint(tokenBlueprintID string) error {
	tokenBlueprintID = strings.TrimSpace(tokenBlueprintID)
	if tokenBlueprintID == "" {
		return ErrInvalidTokenBlueprintID
	}
	t.TokenBlueprintID = tokenBlueprintID
	return nil
}

// ===============================
// Validation
// ===============================

func (t TokenOperation) validate() error {
	if t.ID == "" {
		return ErrInvalidID
	}
	if EnforceIDPrefix && TokenOperationIDPrefix != "" && !strings.HasPrefix(t.ID, TokenOperationIDPrefix) {
		return ErrInvalidID
	}
	if MaxIDLength > 0 && len(t.ID) > MaxIDLength {
		return ErrInvalidID
	}
	if t.TokenBlueprintID == "" {
		return ErrInvalidTokenBlueprintID
	}
	if t.AssigneeID == "" {
		return ErrInvalidAssigneeID
	}
	return nil
}

func (t TokenOperationExtended) validateExtended() error {
	// base must be valid
	if err := t.TokenOperation.validate(); err != nil {
		return err
	}
	if t.TokenName = strings.TrimSpace(t.TokenName); t.TokenName == "" {
		return ErrInvalidTokenName
	}
	if MaxNameLength > 0 && len([]rune(t.TokenName)) > MaxNameLength {
		return ErrInvalidTokenName
	}
	if t.Symbol = strings.TrimSpace(t.Symbol); t.Symbol == "" {
		return ErrInvalidSymbol
	}
	if MaxSymbolLength > 0 && len([]rune(t.Symbol)) > MaxSymbolLength {
		return ErrInvalidSymbol
	}
	if t.BrandID = strings.TrimSpace(t.BrandID); t.BrandID == "" {
		return ErrInvalidBrandID
	}
	if t.AssigneeName = strings.TrimSpace(t.AssigneeName); t.AssigneeName == "" {
		return ErrInvalidAssigneeName
	}
	if MaxNameLength > 0 && len([]rune(t.AssigneeName)) > MaxNameLength {
		return ErrInvalidAssigneeName
	}
	if t.BrandName = strings.TrimSpace(t.BrandName); t.BrandName == "" {
		return ErrInvalidBrandName
	}
	if MaxNameLength > 0 && len([]rune(t.BrandName)) > MaxNameLength {
		return ErrInvalidBrandName
	}
	return nil
}

// TokenOperationDomainDDLs defines SQL for tables used by tokenOperation repository.
const TokenOperationDomainDDLs = `
-- Migration: Initialize TokenOperation domain and related tables
-- Mirrors backend/internal/domain/tokenOperation/entity.go and repository_pg.go

BEGIN;

-- token_operations: minimal operational state tracking
CREATE TABLE IF NOT EXISTS token_operations (
  id                  TEXT        PRIMARY KEY,
  token_blueprint_id  TEXT        NOT NULL,
  assignee_id         TEXT        NOT NULL,
  name                TEXT        NOT NULL DEFAULT '',
  status              TEXT        NOT NULL DEFAULT 'operational',
  updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by          TEXT        NOT NULL DEFAULT '',

  CONSTRAINT chk_to_non_empty CHECK (
    char_length(trim(id)) > 0
    AND char_length(trim(token_blueprint_id)) > 0
    AND char_length(trim(assignee_id)) > 0
  )
);

-- Optional FKs
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='token_blueprints') THEN
    BEGIN
      ALTER TABLE token_operations
        ADD CONSTRAINT fk_to_tb
        FOREIGN KEY (token_blueprint_id) REFERENCES token_blueprints(id) ON DELETE RESTRICT;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;

  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='members') THEN
    BEGIN
      ALTER TABLE token_operations
        ADD CONSTRAINT fk_to_assignee
        FOREIGN KEY (assignee_id) REFERENCES members(id) ON DELETE RESTRICT;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_to_token_blueprint_id ON token_operations(token_blueprint_id);
CREATE INDEX IF NOT EXISTS idx_to_assignee_id        ON token_operations(assignee_id);
CREATE INDEX IF NOT EXISTS idx_to_updated_at         ON token_operations(updated_at);

-- token_holders: wallet holders for a token
CREATE TABLE IF NOT EXISTS token_holders (
  id              TEXT        PRIMARY KEY,
  token_id        TEXT        NOT NULL,
  wallet_address  TEXT        NOT NULL,
  balance         TEXT        NOT NULL,
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT chk_th_non_empty CHECK (
    char_length(trim(id)) > 0
    AND char_length(trim(token_id)) > 0
    AND char_length(trim(wallet_address)) > 0
  )
);

-- Optional FK to tokens table if it exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='tokens') THEN
    BEGIN
      ALTER TABLE token_holders
        ADD CONSTRAINT fk_th_token
        FOREIGN KEY (token_id) REFERENCES tokens(id) ON DELETE CASCADE;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_th_token_id        ON token_holders(token_id);
CREATE INDEX IF NOT EXISTS idx_th_wallet_address  ON token_holders(wallet_address);
CREATE INDEX IF NOT EXISTS idx_th_updated_at      ON token_holders(updated_at);

-- token_update_history: audit of updates
CREATE TABLE IF NOT EXISTS token_update_history (
  id          TEXT        PRIMARY KEY,
  token_id    TEXT        NOT NULL,
  event       TEXT        NOT NULL,
  assignee_id TEXT        NOT NULL,
  note        TEXT        NOT NULL DEFAULT '',
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT chk_tuh_non_empty CHECK (
    char_length(trim(id)) > 0
    AND char_length(trim(token_id)) > 0
    AND char_length(trim(event)) > 0
  )
);

CREATE INDEX IF NOT EXISTS idx_tuh_token_id    ON token_update_history(token_id);
CREATE INDEX IF NOT EXISTS idx_tuh_created_at  ON token_update_history(created_at);

-- token_operation_contents: auxiliary contents tied to operational token
CREATE TABLE IF NOT EXISTS token_operation_contents (
  id           TEXT        PRIMARY KEY,
  token_id     TEXT        NOT NULL,
  type         TEXT        NOT NULL,
  url          TEXT        NOT NULL,
  description  TEXT        NOT NULL DEFAULT '',
  published_by TEXT        NOT NULL DEFAULT '',
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT chk_toc_non_empty CHECK (
    char_length(trim(id)) > 0
    AND char_length(trim(token_id)) > 0
    AND char_length(trim(type)) > 0
    AND char_length(trim(url)) > 0
  ),
  CONSTRAINT chk_toc_url_format CHECK (url ~* '^(https?)://')
);

CREATE INDEX IF NOT EXISTS idx_toc_token_id    ON token_operation_contents(token_id);
CREATE INDEX IF NOT EXISTS idx_toc_type        ON token_operation_contents(type);
CREATE INDEX IF NOT EXISTS idx_toc_created_at  ON token_operation_contents(created_at);

-- product_details: minimal reference table used by repository
CREATE TABLE IF NOT EXISTS product_details (
  id          TEXT PRIMARY KEY,
  name        TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT ''
);

CREATE INDEX IF NOT EXISTS idx_pd_name ON product_details(name);

COMMIT;
`
